// Generated by CoffeeScript 1.6.1
var config, eco, express, fs, getStatus, io, log4js, onCountdownUpdate, path, reset, server, socket, update;

config = require('./config.js').config;

express = require('express');

fs = require('fs');

path = require('path');

eco = require('eco');

io = require('socket.io').listen(config.sockets_port);

log4js = require('log4js');

log4js.replaceConsole();

socket = null;

io.enable('browser client minification');

io.enable('browser client etag');

io.enable('browser client gzip');

io.set('log level', config.log_level);

io.set('transports', config.transports);

server = express();

server.configure(function() {
  server.use('/static', express["static"](path.join(__dirname, '/static')));
  server.use(express.bodyParser());
  return server.use(function(req, res, next) {
    res.header('Access-Control-Allow-Origin', config.allowedDomains);
    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    return next();
  });
});

server.get('/', function(req, res) {
  var context, template;
  template = fs.readFileSync(path.join(__dirname + "/index.eco.html"), "utf-8");
  context = {};
  return res.send(eco.render(template, context));
});

getStatus = function(author) {
  var count, countdown, countdownIntervalID, countdownStart, current, previousStatus, resetTimeoutID, status;
  if (author == null) {
    author = null;
  }
  previousStatus = status;
  count = hungryCount();
  status = 'waiting';
  countdown = countdownValue;
  if (count >= config.leaveat) {
    status = 'leaving';
    if (typeof countdownStart === "undefined" || countdownStart === null) {
      countdownStart = new Date();
      clearInterval(countdownIntervalID);
      countdownIntervalID = setInterval(onCountdownUpdate, 1000);
    }
    if (countdown <= 0) {
      status = 'departed';
      if (previousStatus !== 'departed') {
        console.log("START RESET TIMER -> call reset in " + config.resetAllDelay + "s");
        clearTimeout(resetTimeoutID);
        resetTimeoutID = setTimeout(reset, config.resetAllDelay * 1000);
      }
    }
  }
  current = {
    status: status,
    count: count,
    countdown: countdown
  };
  if (author) {
    current.author = author;
    current.hungry = isHungry(author);
  }
  if (previousStatus !== status) {
    console.log("status: ", previousStatus, '->', status);
    if (status === 'leaving' && previousStatus === 'waiting') {
      hipchat.leaving();
    }
    if (status === 'departed' && previousStatus === 'leaving') {
      hipchat.departed();
    }
  }
  return current;
};

update = function() {
  var statusObject;
  statusObject = getStatus();
  console.log("update", statusObject);
  return io.sockets.emit('update', statusObject);
};

reset = function() {
  var countdownIntervalID, countdownStart, countdownValue, users;
  console.log("RESET");
  users = {};
  socket = null;
  clearTimeout(resetTimeoutID);
  clearInterval(countdownIntervalID);
  countdownStart = null;
  countdownIntervalID = null;
  countdownValue = config.countdown;
  return update();
};

onCountdownUpdate = function() {
  var countdown, countdownValue, diff;
  diff = +new Date() - countdownStart.getTime();
  countdown = config.countdown - Math.round(diff / 1000);
  countdownValue = countdown;
  if (countdown <= 0) {
    clearInterval(countdownIntervalID);
    console.log("finished!");
  }
  return update();
};

console.log("http server running on port " + config.server_port);

console.log("sockets server running on port " + config.sockets_port);

server.listen(config.server_port);
